import sys
import traceback
import logging
from datetime import datetime
from aiohttp import web
from botbuilder.core import TurnContext
from botbuilder.core.integration import aiohttp_error_middleware
from botbuilder.integration.aiohttp import CloudAdapter
from botbuilder.schema import Activity, ActivityTypes
from azure.identity import ManagedIdentityCredential
from botframework.connector.auth import MicrosoftAppCredentials, BotFrameworkAuthentication
from config import DefaultConfig
from bot import MyBot
from http import HTTPStatus
from aiohttp.web import Response, json_response

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

CONFIG = DefaultConfig()

class MSIAppCredentials(MicrosoftAppCredentials):
    def __init__(self, client_id: str, app_id: str):
        super().__init__(app_id, None)
        self.credential = ManagedIdentityCredential(client_id=client_id)

    def get_access_token(self, force_refresh: bool = False):
        token = self.credential.get_token("https://api.botframework.com/.default")
        if not token or not token.token:
            raise Exception("Failed to acquire access token using Managed Identity.")
        return token.token

class CustomBotFrameworkAuthentication(BotFrameworkAuthentication):
    def __init__(self, credentials: MicrosoftAppCredentials):
        self.credentials = credentials

    async def authenticate_request(self, *args, **kwargs):
        class Result:
            caller_id = None
        return Result()

    async def create_connector_factory(self, *args, **kwargs):
        raise NotImplementedError()

    async def create_user_token_client(self, *args, **kwargs):
        raise NotImplementedError()

# Instantiate Managed Identity credentials and inject
msi_credentials = MSIAppCredentials(CONFIG.USER_ASSIGNED_CLIENT_ID, CONFIG.APP_ID)
auth = CustomBotFrameworkAuthentication(msi_credentials)

# Create adapter
ADAPTER = CloudAdapter(auth)

# Catch-all for errors
async def on_error(context: TurnContext, error: Exception):
    logger.error(f"[on_turn_error] Unhandled error: {error}", exc_info=True)
    traceback.print_exc()
    await context.send_activity("The bot encountered an error or bug.")
    await context.send_activity("To continue to run this bot, please fix the bot source code.")
    if context.activity.channel_id == "emulator":
        trace_activity = Activity(
            label="TurnError",
            name="on_turn_error Trace",
            timestamp=datetime.utcnow(),
            type=ActivityTypes.trace,
            value=f"{error}",
            value_type="https://www.botframework.com/schemas/error",
        )
        await context.send_activity(trace_activity)

ADAPTER.on_turn_error = on_error

BOT = MyBot()

# Aiohttp route
async def messages(req: web.Request) -> web.Response:
    logger.info("Received request at /api/messages")
    if "application/json" in req.headers.get("Content-Type", ""):
        body = await req.json()
    else:
        logger.warning("Unsupported media type")
        return Response(status=HTTPStatus.UNSUPPORTED_MEDIA_TYPE)

    activity = Activity().deserialize(body)
    auth_header = req.headers.get("Authorization", "")

    response = await ADAPTER.process_activity(activity, auth_header, BOT.on_turn)
    if response:
        logger.info("Response generated by bot")
        return json_response(data=response.body, status=response.status)
    logger.info("No response generated by bot")
    return Response(status=HTTPStatus.OK)

APP = web.Application(middlewares=[aiohttp_error_middleware])
APP.router.add_post("/api/messages", messages)

if __name__ == "__main__":
    try:
        logger.info("Starting web application")
        web.run_app(APP, host="0.0.0.0", port=CONFIG.PORT)
    except Exception as error:
        logger.error("Failed to start web application", exc_info=True)
        raise error